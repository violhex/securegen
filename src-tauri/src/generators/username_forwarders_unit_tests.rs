//! Unit tests for individual username forwarders
//! 
//! These tests verify the specific implementation details of each forwarder:
//! 1. Correct API endpoint construction
//! 2. Proper authentication header handling
//! 3. Request body formatting
//! 4. Response parsing and validation
//! 5. Error handling and status code interpretation
//! 6. Edge cases and malformed data handling

use crate::generators::username::UsernameError;
use reqwest::StatusCode;
use serde_json::json;
use wiremock::{
    matchers::{basic_auth, header, method, path, query_param, bearer_token},
    Mock, MockServer, ResponseTemplate,
};

#[cfg(test)]
mod addyio_unit_tests {
    use super::*;
    use crate::generators::username_forwarders::addyio;

    #[tokio::test]
    async fn test_correct_endpoint_and_headers() {
        let server = MockServer::start().await;
        let client = reqwest::Client::new();

        server
            .register(
                Mock::given(method("POST"))
                    .and(path("/api/v1/aliases"))
                    .and(header("content-type", "application/json"))
                    .and(header("authorization", "Bearer test_api_token"))
                    .and(header("x-requested-with", "XMLHttpRequest"))
                    .respond_with(ResponseTemplate::new(201).set_body_json(json!({
                        "data": { "email": "test@example.com" }
                    }))),
            )
            .await;

        let result = addyio::generate(
            &client,
            "test_api_token".to_string(),
            "example.com".to_string(),
            server.uri(),
            Some("github.com".to_string()),
        ).await;

        assert!(result.is_ok());
        server.verify().await;
    }

    #[tokio::test]
    async fn test_request_body_format() {
        let server = MockServer::start().await;
        let client = reqwest::Client::new();

        server
            .register(
                Mock::given(method("POST"))
                    .and(path("/api/v1/aliases"))
                    .and(wiremock::matchers::body_json(json!({
                        "domain": "testdomain.com",
                        "description": "Generated by Bitwarden for example.org"
                    })))
                    .respond_with(ResponseTemplate::new(201).set_body_json(json!({
                        "data": { "email": "created@testdomain.com" }
                    }))),
            )
            .await;

        let result = addyio::generate(
            &client,
            "token".to_string(),
            "testdomain.com".to_string(),
            server.uri(),
            Some("example.org".to_string()),
        ).await;

        assert!(result.is_ok());
        assert_eq!(result.unwrap(), "created@testdomain.com");
        server.verify().await;
    }

    #[tokio::test]
    async fn test_no_website_description() {
        let server = MockServer::start().await;
        let client = reqwest::Client::new();

        server
            .register(
                Mock::given(method("POST"))
                    .and(wiremock::matchers::body_json(json!({
                        "domain": "mydomain.com",
                        "description": "Generated by Bitwarden"
                    })))
                    .respond_with(ResponseTemplate::new(201).set_body_json(json!({
                        "data": { "email": "nowebsite@mydomain.com" }
                    }))),
            )
            .await;

        let result = addyio::generate(
            &client,
            "token".to_string(),
            "mydomain.com".to_string(),
            server.uri(),
            None,
        ).await;

        assert!(result.is_ok());
        assert_eq!(result.unwrap(), "nowebsite@mydomain.com");
        server.verify().await;
    }

    #[tokio::test]
    async fn test_malformed_response() {
        let server = MockServer::start().await;
        let client = reqwest::Client::new();

        // Response missing required fields
        server
            .register(
                Mock::given(method("POST"))
                    .respond_with(ResponseTemplate::new(201).set_body_json(json!({
                        "data": { "id": "123" } // Missing email field
                    }))),
            )
            .await;

        let result = addyio::generate(
            &client,
            "token".to_string(),
            "domain.com".to_string(),
            server.uri(),
            None,
        ).await;

        // Should fail to deserialize due to missing email field
        assert!(result.is_err());
        server.verify().await;
    }

    #[tokio::test]
    async fn test_various_http_errors() {
        let test_cases = vec![
            (401, "Unauthorized - Invalid API key"),
            (403, "Forbidden - Invalid domain"),
            (404, "Not Found - Invalid endpoint"),
            (429, "Too Many Requests"),
            (500, "Internal Server Error"),
        ];

        for (status_code, _description) in test_cases {
            let server = MockServer::start().await;
            let client = reqwest::Client::new();

            server
                .register(
                    Mock::given(method("POST"))
                        .respond_with(ResponseTemplate::new(status_code)),
                )
                .await;

            let result = addyio::generate(
                &client,
                "token".to_string(),
                "domain.com".to_string(),
                server.uri(),
                None,
            ).await;

            if status_code == 401 {
                assert!(matches!(result, Err(UsernameError::InvalidApiKey)));
            } else {
                assert!(result.is_err());
                // Should be a reqwest error for other status codes
                assert!(matches!(result, Err(UsernameError::Reqwest(_))));
            }

            server.verify().await;
        }
    }
}

#[cfg(test)]
mod duckduckgo_unit_tests {
    use super::*;
    use crate::generators::username_forwarders::duckduckgo;

    #[tokio::test]
    async fn test_correct_api_endpoint() {
        let server = MockServer::start().await;
        let client = reqwest::Client::new();

        server
            .register(
                Mock::given(method("POST"))
                    .and(path("/api/email/addresses"))
                    .and(header("content-type", "application/json"))
                    .and(bearer_token("ddg_token"))
                    .respond_with(ResponseTemplate::new(201).set_body_json(json!({
                        "address": "generated123"
                    }))),
            )
            .await;

        // Test internal function that allows custom API URL
        let result = duckduckgo::generate_with_api_url(
            &client,
            "ddg_token".to_string(),
            server.uri(),
        ).await;

        assert!(result.is_ok());
        assert_eq!(result.unwrap(), "generated123@duck.com");
        server.verify().await;
    }

    #[tokio::test]
    async fn test_production_endpoint() {
        // Test that the production function uses the correct default URL
        // We'll mock a failing request to verify the URL is correct
        let client = reqwest::Client::builder()
            .timeout(std::time::Duration::from_millis(100))
            .build()
            .unwrap();

        let result = duckduckgo::generate(
            &client,
            "fake_token".to_string(),
        ).await;

        // Should fail with a network error since we're using a fake token
        // against the real endpoint (which we can't reach in tests)
        assert!(result.is_err());
    }

    #[tokio::test]
    async fn test_empty_response_handling() {
        let server = MockServer::start().await;
        let client = reqwest::Client::new();

        server
            .register(
                Mock::given(method("POST"))
                    .respond_with(ResponseTemplate::new(201).set_body_json(json!({}))),
            )
            .await;

        let result = duckduckgo::generate_with_api_url(
            &client,
            "token".to_string(),
            server.uri(),
        ).await;

        // Should fail due to missing address field
        assert!(result.is_err());
        server.verify().await;
    }

    #[tokio::test]
    async fn test_special_characters_in_address() {
        let server = MockServer::start().await;
        let client = reqwest::Client::new();

        server
            .register(
                Mock::given(method("POST"))
                    .respond_with(ResponseTemplate::new(201).set_body_json(json!({
                        "address": "test-address_123.special"
                    }))),
            )
            .await;

        let result = duckduckgo::generate_with_api_url(
            &client,
            "token".to_string(),
            server.uri(),
        ).await;

        assert!(result.is_ok());
        assert_eq!(result.unwrap(), "test-address_123.special@duck.com");
        server.verify().await;
    }
}

#[cfg(test)]
mod firefox_unit_tests {
    use super::*;
    use crate::generators::username_forwarders::firefox;

    #[tokio::test]
    async fn test_token_authentication_format() {
        let server = MockServer::start().await;
        let client = reqwest::Client::new();

        server
            .register(
                Mock::given(method("POST"))
                    .and(path("/api/v1/relayaddresses/"))
                    .and(header("authorization", "Token my_firefox_token"))
                    .respond_with(ResponseTemplate::new(201).set_body_json(json!({
                        "full_address": "relay@mozmail.com"
                    }))),
            )
            .await;

        let result = firefox::generate_with_api_url(
            &client,
            "my_firefox_token".to_string(),
            None,
            server.uri(),
        ).await;

        assert!(result.is_ok());
        server.verify().await;
    }

    #[tokio::test]
    async fn test_request_with_website_context() {
        let server = MockServer::start().await;
        let client = reqwest::Client::new();

        server
            .register(
                Mock::given(method("POST"))
                    .and(wiremock::matchers::body_json(json!({
                        "enabled": true,
                        "generated_for": "github.com",
                        "description": "github.com"
                    })))
                    .respond_with(ResponseTemplate::new(201).set_body_json(json!({
                        "full_address": "github123@mozmail.com"
                    }))),
            )
            .await;

        let result = firefox::generate_with_api_url(
            &client,
            "token".to_string(),
            Some("github.com".to_string()),
            server.uri(),
        ).await;

        assert!(result.is_ok());
        assert_eq!(result.unwrap(), "github123@mozmail.com");
        server.verify().await;
    }

    #[tokio::test]
    async fn test_request_without_website() {
        let server = MockServer::start().await;
        let client = reqwest::Client::new();

        server
            .register(
                Mock::given(method("POST"))
                    .and(wiremock::matchers::body_json(json!({
                        "enabled": true,
                        "description": "Generated by Bitwarden"
                    })))
                    .respond_with(ResponseTemplate::new(201).set_body_json(json!({
                        "full_address": "nosite456@mozmail.com"
                    }))),
            )
            .await;

        let result = firefox::generate_with_api_url(
            &client,
            "token".to_string(),
            None,
            server.uri(),
        ).await;

        assert!(result.is_ok());
        assert_eq!(result.unwrap(), "nosite456@mozmail.com");
        server.verify().await;
    }

    #[tokio::test]
    async fn test_rate_limiting_response() {
        let server = MockServer::start().await;
        let client = reqwest::Client::new();

        server
            .register(
                Mock::given(method("POST"))
                    .respond_with(ResponseTemplate::new(429).set_body_raw("Rate limited", "text/plain")),
            )
            .await;

        let result = firefox::generate_with_api_url(
            &client,
            "token".to_string(),
            None,
            server.uri(),
        ).await;

        assert!(result.is_err());
        assert!(matches!(result, Err(UsernameError::Reqwest(_))));
        server.verify().await;
    }
}

#[cfg(test)]
mod fastmail_unit_tests {
    use super::*;
    use crate::generators::username_forwarders::fastmail;

    #[tokio::test]
    async fn test_jmap_session_discovery() {
        let server = MockServer::start().await;
        let client = reqwest::Client::new();

        // Mock the JMAP session discovery
        server
            .register(
                Mock::given(method("GET"))
                    .and(path("/.well-known/jmap"))
                    .and(bearer_token("fastmail_token"))
                    .respond_with(ResponseTemplate::new(200).set_body_json(json!({
                        "primaryAccounts": {
                            "https://www.fastmail.com/dev/maskedemail": "account_id_123"
                        }
                    }))),
            )
            .await;

        // Mock the masked email creation
        server
            .register(
                Mock::given(method("POST"))
                    .and(path("/jmap/api/"))
                    .respond_with(ResponseTemplate::new(200).set_body_json(json!({
                        "methodResponses": [
                            ["MaskedEmail/set", {
                                "created": {
                                    "new-masked-email": {
                                        "email": "masked@fastmail.com"
                                    }
                                }
                            }]
                        ]
                    }))),
            )
            .await;

        let result = fastmail::generate_with_api_url(
            &client,
            "fastmail_token".to_string(),
            Some("example.com".to_string()),
            server.uri(),
        ).await;

        assert!(result.is_ok());
        assert_eq!(result.unwrap(), "masked@fastmail.com");
        server.verify().await;
    }

    #[tokio::test]
    async fn test_jmap_request_format() {
        let server = MockServer::start().await;
        let client = reqwest::Client::new();

        server
            .register(
                Mock::given(method("GET"))
                    .and(path("/.well-known/jmap"))
                    .respond_with(ResponseTemplate::new(200).set_body_json(json!({
                        "primaryAccounts": {
                            "https://www.fastmail.com/dev/maskedemail": "test_account"
                        }
                    }))),
            )
            .await;

        // Verify the exact JMAP request format (simplified check)
        server
            .register(
                Mock::given(method("POST"))
                    .and(path("/jmap/api/"))
                    .respond_with(ResponseTemplate::new(200).set_body_json(json!({
                        "methodResponses": [
                            ["MaskedEmail/set", {
                                "created": {
                                    "new-masked-email": {
                                        "email": "jmap@fastmail.com"
                                    }
                                }
                            }]
                        ]
                    }))),
            )
            .await;

        let result = fastmail::generate_with_api_url(
            &client,
            "token".to_string(),
            Some("site.com".to_string()),
            server.uri(),
        ).await;

        assert!(result.is_ok());
        server.verify().await;
    }

    #[tokio::test]
    async fn test_jmap_error_response() {
        let server = MockServer::start().await;
        let client = reqwest::Client::new();

        server
            .register(
                Mock::given(method("GET"))
                    .and(path("/.well-known/jmap"))
                    .respond_with(ResponseTemplate::new(200).set_body_json(json!({
                        "primaryAccounts": {
                            "https://www.fastmail.com/dev/maskedemail": "account_id"
                        }
                    }))),
            )
            .await;

        // Return a JMAP error response
        server
            .register(
                Mock::given(method("POST"))
                    .and(path("/jmap/api/"))
                    .respond_with(ResponseTemplate::new(200).set_body_json(json!({
                        "methodResponses": [
                            ["error", {
                                "description": "Invalid account ID"
                            }]
                        ]
                    }))),
            )
            .await;

        let result = fastmail::generate_with_api_url(
            &client,
            "token".to_string(),
            None,
            server.uri(),
        ).await;

        assert!(result.is_err());
        if let Err(UsernameError::ResponseContent { status, message }) = result {
            assert_eq!(message, "Invalid account ID");
        } else {
            panic!("Expected ResponseContent error");
        }
        server.verify().await;
    }

    #[tokio::test]
    async fn test_missing_primary_account() {
        let server = MockServer::start().await;
        let client = reqwest::Client::new();

        // Return session without the required primary account
        server
            .register(
                Mock::given(method("GET"))
                    .and(path("/.well-known/jmap"))
                    .respond_with(ResponseTemplate::new(200).set_body_json(json!({
                        "primaryAccounts": {
                            "urn:ietf:params:jmap:mail": "some_other_account"
                        }
                    }))),
            )
            .await;

        server
            .register(
                Mock::given(method("POST"))
                    .and(path("/jmap/api/"))
                    .respond_with(ResponseTemplate::new(200).set_body_json(json!({
                        "methodResponses": [
                            ["MaskedEmail/set", {
                                "created": {
                                    "new-masked-email": {
                                        "email": "fallback@fastmail.com"
                                    }
                                }
                            }]
                        ]
                    }))),
            )
            .await;

        let result = fastmail::generate_with_api_url(
            &client,
            "token".to_string(),
            None,
            server.uri(),
        ).await;

        // Should still work with empty account ID
        assert!(result.is_ok());
        server.verify().await;
    }
}

#[cfg(test)]
mod forwardemail_unit_tests {
    use super::*;
    use crate::generators::username_forwarders::forwardemail;

    #[tokio::test]
    async fn test_basic_auth_encoding() {
        let server = MockServer::start().await;
        let client = reqwest::Client::new();

        server
            .register(
                Mock::given(method("POST"))
                    .and(path("/v1/domains/example.com/aliases"))
                    .and(basic_auth("my_api_token", ""))
                    .respond_with(ResponseTemplate::new(201).set_body_json(json!({
                        "name": "alias123",
                        "domain": { "name": "example.com" }
                    }))),
            )
            .await;

        let result = forwardemail::generate_with_api_url(
            &client,
            "my_api_token".to_string(),
            "example.com".to_string(),
            None,
            server.uri(),
        ).await;

        assert!(result.is_ok());
        assert_eq!(result.unwrap(), "alias123@example.com");
        server.verify().await;
    }

    #[tokio::test]
    async fn test_request_with_labels() {
        let server = MockServer::start().await;
        let client = reqwest::Client::new();

        server
            .register(
                Mock::given(method("POST"))
                    .and(wiremock::matchers::body_json(json!({
                        "labels": "github.com",
                        "description": "Generated by Bitwarden for github.com"
                    })))
                    .respond_with(ResponseTemplate::new(201).set_body_json(json!({
                        "name": "labeled456",
                        "domain": { "name": "mydomain.org" }
                    }))),
            )
            .await;

        let result = forwardemail::generate_with_api_url(
            &client,
            "token".to_string(),
            "mydomain.org".to_string(),
            Some("github.com".to_string()),
            server.uri(),
        ).await;

        assert!(result.is_ok());
        assert_eq!(result.unwrap(), "labeled456@mydomain.org");
        server.verify().await;
    }

    #[tokio::test]
    async fn test_request_without_labels() {
        let server = MockServer::start().await;
        let client = reqwest::Client::new();

        server
            .register(
                Mock::given(method("POST"))
                    .and(wiremock::matchers::body_json(json!({
                        "description": "Generated by Bitwarden"
                    })))
                    .respond_with(ResponseTemplate::new(201).set_body_json(json!({
                        "name": "nolabels789",
                        "domain": { "name": "testdomain.com" }
                    }))),
            )
            .await;

        let result = forwardemail::generate_with_api_url(
            &client,
            "token".to_string(),
            "testdomain.com".to_string(),
            None,
            server.uri(),
        ).await;

        assert!(result.is_ok());
        assert_eq!(result.unwrap(), "nolabels789@testdomain.com");
        server.verify().await;
    }

    #[tokio::test]
    async fn test_error_response_handling() {
        let server = MockServer::start().await;
        let client = reqwest::Client::new();

        // Test error message in response body
        server
            .register(
                Mock::given(method("POST"))
                    .respond_with(ResponseTemplate::new(400).set_body_json(json!({
                        "statusCode": 400,
                        "error": "Bad Request",
                        "message": "Invalid domain configuration"
                    }))),
            )
            .await;

        let result = forwardemail::generate_with_api_url(
            &client,
            "token".to_string(),
            "invalid.com".to_string(),
            None,
            server.uri(),
        ).await;

        assert!(result.is_err());
        if let Err(UsernameError::ResponseContent { status, message }) = result {
            assert_eq!(status, StatusCode::BAD_REQUEST);
            assert_eq!(message, "Invalid domain configuration");
        } else {
            panic!("Expected ResponseContent error");
        }
        server.verify().await;
    }

    #[tokio::test]
    async fn test_fallback_domain_handling() {
        let server = MockServer::start().await;
        let client = reqwest::Client::new();

        // Response with missing domain name - should fallback to original domain
        server
            .register(
                Mock::given(method("POST"))
                    .respond_with(ResponseTemplate::new(201).set_body_json(json!({
                        "name": "fallback123",
                        "domain": {} // Missing name field
                    }))),
            )
            .await;

        let result = forwardemail::generate_with_api_url(
            &client,
            "token".to_string(),
            "fallback.com".to_string(),
            None,
            server.uri(),
        ).await;

        assert!(result.is_ok());
        assert_eq!(result.unwrap(), "fallback123@fallback.com");
        server.verify().await;
    }
}

#[cfg(test)]
mod simplelogin_unit_tests {
    use super::*;
    use crate::generators::username_forwarders::simplelogin;

    #[tokio::test]
    async fn test_authentication_header_format() {
        let server = MockServer::start().await;
        let client = reqwest::Client::new();

        server
            .register(
                Mock::given(method("POST"))
                    .and(path("/api/alias/random/new"))
                    .and(header("authentication", "my_api_key"))
                    .respond_with(ResponseTemplate::new(201).set_body_json(json!({
                        "alias": "simple@simplelogin.co"
                    }))),
            )
            .await;

        let result = simplelogin::generate_with_api_url(
            &client,
            "my_api_key".to_string(),
            server.uri(),
            None,
        ).await;

        assert!(result.is_ok());
        assert_eq!(result.unwrap(), "simple@simplelogin.co");
        server.verify().await;
    }

    #[tokio::test]
    async fn test_hostname_query_parameter() {
        let server = MockServer::start().await;
        let client = reqwest::Client::new();

        server
            .register(
                Mock::given(method("POST"))
                    .and(path("/api/alias/random/new"))
                    .and(query_param("hostname", "example.com"))
                    .respond_with(ResponseTemplate::new(201).set_body_json(json!({
                        "alias": "hostname@simplelogin.co"
                    }))),
            )
            .await;

        let result = simplelogin::generate_with_api_url(
            &client,
            "token".to_string(),
            server.uri(),
            Some("example.com".to_string()),
        ).await;

        assert!(result.is_ok());
        assert_eq!(result.unwrap(), "hostname@simplelogin.co");
        server.verify().await;
    }

    #[tokio::test]
    async fn test_url_encoding_in_hostname() {
        let server = MockServer::start().await;
        let client = reqwest::Client::new();

        // Test special characters that need URL encoding
        server
            .register(
                Mock::given(method("POST"))
                    .and(path("/api/alias/random/new"))
                    .and(query_param("hostname", "test%20site.com/path%3Fparam%3Dvalue"))
                    .respond_with(ResponseTemplate::new(201).set_body_json(json!({
                        "alias": "encoded@simplelogin.co"
                    }))),
            )
            .await;

        let result = simplelogin::generate_with_api_url(
            &client,
            "token".to_string(),
            server.uri(),
            Some("test site.com/path?param=value".to_string()),
        ).await;

        assert!(result.is_ok());
        assert_eq!(result.unwrap(), "encoded@simplelogin.co");
        server.verify().await;
    }

    #[tokio::test]
    async fn test_request_body_format() {
        let server = MockServer::start().await;
        let client = reqwest::Client::new();

        server
            .register(
                Mock::given(method("POST"))
                    .and(wiremock::matchers::body_json(json!({
                        "note": "Generated by SecureGen"
                    })))
                    .respond_with(ResponseTemplate::new(201).set_body_json(json!({
                        "alias": "note@simplelogin.co"
                    }))),
            )
            .await;

        let result = simplelogin::generate_with_api_url(
            &client,
            "token".to_string(),
            server.uri(),
            None,
        ).await;

        assert!(result.is_ok());
        assert_eq!(result.unwrap(), "note@simplelogin.co");
        server.verify().await;
    }

    #[tokio::test]
    async fn test_no_hostname_parameter() {
        let server = MockServer::start().await;
        let client = reqwest::Client::new();

        // Should not have hostname query parameter when website is None
        server
            .register(
                Mock::given(method("POST"))
                    .and(path("/api/alias/random/new"))
                    .and(wiremock::matchers::query_param_is_missing("hostname"))
                    .respond_with(ResponseTemplate::new(201).set_body_json(json!({
                        "alias": "nohostname@simplelogin.co"
                    }))),
            )
            .await;

        let result = simplelogin::generate_with_api_url(
            &client,
            "token".to_string(),
            server.uri(),
            None,
        ).await;

        assert!(result.is_ok());
        assert_eq!(result.unwrap(), "nohostname@simplelogin.co");
        server.verify().await;
    }

    #[tokio::test]
    async fn test_quota_exceeded_error() {
        let server = MockServer::start().await;
        let client = reqwest::Client::new();

        server
            .register(
                Mock::given(method("POST"))
                    .respond_with(ResponseTemplate::new(402).set_body_json(json!({
                        "error": "Quota exceeded"
                    }))),
            )
            .await;

        let result = simplelogin::generate_with_api_url(
            &client,
            "token".to_string(),
            server.uri(),
            None,
        ).await;

        assert!(result.is_err());
        assert!(matches!(result, Err(UsernameError::Reqwest(_))));
        server.verify().await;
    }
}

/// Tests that verify edge cases and boundary conditions
#[cfg(test)]
mod edge_case_tests {
    use super::*;

    #[tokio::test]
    async fn test_empty_strings_handling() {
        let server = MockServer::start().await;
        let client = reqwest::Client::new();

        // Test all forwarders with empty strings where applicable
        server
            .register(
                Mock::given(method("POST"))
                    .respond_with(ResponseTemplate::new(201).set_body_json(json!({
                        "data": { "email": "empty@test.com" }
                    }))),
            )
            .await;

        server
            .register(
                Mock::given(method("GET"))
                    .respond_with(ResponseTemplate::new(200).set_body_json(json!({
                        "primaryAccounts": {
                            "https://www.fastmail.com/dev/maskedemail": ""
                        }
                    }))),
            )
            .await;

        // Test with empty domain (should still work for most services)
        let result = crate::generators::username_forwarders::addyio::generate(
            &client,
            "token".to_string(),
            "".to_string(), // Empty domain
            server.uri(),
            Some("".to_string()), // Empty website
        ).await;

        // Should still work but behavior depends on the service
        server.verify().await;
    }

    #[tokio::test]
    async fn test_very_long_inputs() {
        let server = MockServer::start().await;
        let client = reqwest::Client::new();

        server
            .register(
                Mock::given(method("POST"))
                    .respond_with(ResponseTemplate::new(201).set_body_json(json!({
                        "alias": "long@simplelogin.co"
                    }))),
            )
            .await;

        // Test with very long website name
        let long_website = "a".repeat(1000);
        
        let result = crate::generators::username_forwarders::simplelogin::generate_with_api_url(
            &client,
            "token".to_string(),
            server.uri(),
            Some(long_website),
        ).await;

        // Should handle long inputs gracefully
        assert!(result.is_ok() || result.is_err()); // Either works or fails gracefully
        server.verify().await;
    }

    #[tokio::test]
    async fn test_unicode_characters() {
        let server = MockServer::start().await;
        let client = reqwest::Client::new();

        server
            .register(
                Mock::given(method("POST"))
                    .respond_with(ResponseTemplate::new(201).set_body_json(json!({
                        "alias": "unicode@simplelogin.co"
                    }))),
            )
            .await;

        // Test with Unicode characters in website name
        let unicode_website = "测试网站.com";
        
        let result = crate::generators::username_forwarders::simplelogin::generate_with_api_url(
            &client,
            "token".to_string(),
            server.uri(),
            Some(unicode_website.to_string()),
        ).await;

        // Should handle Unicode properly (URL encoded)
        server.verify().await;
    }

    #[tokio::test]
    async fn test_connection_failure_handling() {
        let client = reqwest::Client::builder()
            .timeout(std::time::Duration::from_millis(50))
            .build()
            .unwrap();

        // Use a non-routable IP to trigger connection failure
        let result = crate::generators::username_forwarders::addyio::generate(
            &client,
            "token".to_string(),
            "domain.com".to_string(),
            "http://192.0.2.1:12345".to_string(), // RFC 5737 test address
            None,
        ).await;

        assert!(result.is_err());
        assert!(matches!(result, Err(UsernameError::Reqwest(_))));
    }
} 