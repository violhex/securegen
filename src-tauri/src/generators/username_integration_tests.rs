//! Integration tests for username forwarders
//! 
//! These tests verify that:
//! 1. All forwarder implementations work correctly
//! 2. Integration with the main username generation system works
//! 3. Error handling works as expected
//! 4. API request/response handling is correct
//! 5. Authentication flows work properly

use crate::generators::username::{
    generate_username, ForwarderServiceType, UsernameError, UsernameGeneratorRequest,
};
use serde_json::json;
use std::time::Duration;
use tokio::time::timeout;
use wiremock::{
    matchers::{header, method, path, query_param},
    Mock, MockServer, ResponseTemplate,
};

const TEST_TIMEOUT: Duration = Duration::from_secs(30);

/// Test helper to create an HTTP client with timeout
fn create_test_client() -> reqwest::Client {
    reqwest::Client::builder()
        .timeout(Duration::from_secs(10))
        .build()
        .expect("Failed to create HTTP client")
}

/// Test helper to validate email address format
fn is_valid_email(email: &str) -> bool {
    email.contains('@') && email.len() > 3 && !email.starts_with('@') && !email.ends_with('@')
}

#[cfg(test)]
mod addyio_tests {
    use super::*;

    #[tokio::test]
    async fn test_addyio_successful_generation() {
        let server = MockServer::start().await;
        let client = create_test_client();

        // Mock successful response
        server
            .register(
                Mock::given(method("POST"))
                    .and(path("/api/v1/aliases"))
                    .and(header("content-type", "application/json"))
                    .and(header("authorization", "Bearer test_token"))
                    .and(header("x-requested-with", "XMLHttpRequest"))
                    .respond_with(ResponseTemplate::new(201).set_body_json(json!({
                        "data": {
                            "id": "50c9e585-e7f5-41c4-9016-9014c15454bc",
                            "user_id": "ca0a4e09-c266-4f6f-845c-958db5090f09",
                            "local_part": "alias123",
                            "domain": "testdomain.com",
                            "email": "alias123@testdomain.com",
                            "active": true
                        }
                    }))),
            )
            .await;

        let service = ForwarderServiceType::AddyIo {
            api_token: "test_token".to_string(),
            domain: "testdomain.com".to_string(),
            base_url: server.uri(),
        };

        let request = UsernameGeneratorRequest::Forwarded {
            service,
            website: Some("github.com".to_string()),
        };

        let result = timeout(
            TEST_TIMEOUT,
            generate_username(request, &client)
        ).await.expect("Test timed out");

        assert!(result.is_ok());
        let email = result.unwrap();
        assert_eq!(email, "alias123@testdomain.com");
        assert!(is_valid_email(&email));

        server.verify().await;
    }

    #[tokio::test]
    async fn test_addyio_unauthorized_error() {
        let server = MockServer::start().await;
        let client = create_test_client();

        // Mock unauthorized response
        server
            .register(
                Mock::given(method("POST"))
                    .and(path("/api/v1/aliases"))
                    .respond_with(ResponseTemplate::new(401)),
            )
            .await;

        let service = ForwarderServiceType::AddyIo {
            api_token: "invalid_token".to_string(),
            domain: "testdomain.com".to_string(),
            base_url: server.uri(),
        };

        let request = UsernameGeneratorRequest::Forwarded {
            service,
            website: None,
        };

        let result = generate_username(request, &client).await;
        assert!(result.is_err());
        
        if let Err(UsernameError::InvalidApiKey) = result {
            // Expected error type
        } else {
            panic!("Expected InvalidApiKey error, got: {:?}", result);
        }

        server.verify().await;
    }

    #[tokio::test]
    async fn test_addyio_with_website_context() {
        let server = MockServer::start().await;
        let client = create_test_client();

        server
            .register(
                Mock::given(method("POST"))
                    .and(path("/api/v1/aliases"))
                    .and(wiremock::matchers::body_json(json!({
                        "domain": "mydomain.com",
                        "description": "Generated by Bitwarden for example.com"
                    })))
                    .respond_with(ResponseTemplate::new(201).set_body_json(json!({
                        "data": {
                            "email": "context123@mydomain.com"
                        }
                    }))),
            )
            .await;

        let service = ForwarderServiceType::AddyIo {
            api_token: "test_token".to_string(),
            domain: "mydomain.com".to_string(),
            base_url: server.uri(),
        };

        let request = UsernameGeneratorRequest::Forwarded {
            service,
            website: Some("example.com".to_string()),
        };

        let result = generate_username(request, &client).await;
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), "context123@mydomain.com");

        server.verify().await;
    }
}

#[cfg(test)]
mod duckduckgo_tests {
    use super::*;

    #[tokio::test]
    async fn test_duckduckgo_successful_generation() {
        let server = MockServer::start().await;
        let client = create_test_client();

        server
            .register(
                Mock::given(method("POST"))
                    .and(path("/api/email/addresses"))
                    .and(header("authorization", "Bearer ddg_token"))
                    .respond_with(ResponseTemplate::new(201).set_body_json(json!({
                        "address": "randomstr123"
                    }))),
            )
            .await;

        let service = ForwarderServiceType::DuckDuckGo {
            token: "ddg_token".to_string(),
        };

        let request = UsernameGeneratorRequest::Forwarded {
            service,
            website: None,
        };

        let result = generate_username(request, &client).await;
        assert!(result.is_ok());
        let email = result.unwrap();
        assert_eq!(email, "randomstr123@duck.com");
        assert!(is_valid_email(&email));

        server.verify().await;
    }

    #[tokio::test]
    async fn test_duckduckgo_invalid_token() {
        let server = MockServer::start().await;
        let client = create_test_client();

        server
            .register(
                Mock::given(method("POST"))
                    .and(path("/api/email/addresses"))
                    .respond_with(ResponseTemplate::new(401)),
            )
            .await;

        let service = ForwarderServiceType::DuckDuckGo {
            token: "invalid_token".to_string(),
        };

        let request = UsernameGeneratorRequest::Forwarded {
            service,
            website: None,
        };

        let result = generate_username(request, &client).await;
        assert!(result.is_err());
        assert!(matches!(result.unwrap_err(), UsernameError::InvalidApiKey));

        server.verify().await;
    }
}

#[cfg(test)]
mod firefox_tests {
    use super::*;

    #[tokio::test]
    async fn test_firefox_successful_generation() {
        let server = MockServer::start().await;
        let client = create_test_client();

        server
            .register(
                Mock::given(method("POST"))
                    .and(path("/api/v1/relayaddresses/"))
                    .and(header("authorization", "Token firefox_token"))
                    .respond_with(ResponseTemplate::new(201).set_body_json(json!({
                        "full_address": "relay123@mozmail.com"
                    }))),
            )
            .await;

        let service = ForwarderServiceType::Firefox {
            api_token: "firefox_token".to_string(),
        };

        let request = UsernameGeneratorRequest::Forwarded {
            service,
            website: Some("github.com".to_string()),
        };

        let result = generate_username(request, &client).await;
        assert!(result.is_ok());
        let email = result.unwrap();
        assert_eq!(email, "relay123@mozmail.com");
        assert!(is_valid_email(&email));

        server.verify().await;
    }

    #[tokio::test]
    async fn test_firefox_with_website_description() {
        let server = MockServer::start().await;
        let client = create_test_client();

        server
            .register(
                Mock::given(method("POST"))
                    .and(path("/api/v1/relayaddresses/"))
                    .and(wiremock::matchers::body_json(json!({
                        "enabled": true,
                        "generated_for": "example.com",
                        "description": "example.com"
                    })))
                    .respond_with(ResponseTemplate::new(201).set_body_json(json!({
                        "full_address": "context456@mozmail.com"
                    }))),
            )
            .await;

        let service = ForwarderServiceType::Firefox {
            api_token: "firefox_token".to_string(),
        };

        let request = UsernameGeneratorRequest::Forwarded {
            service,
            website: Some("example.com".to_string()),
        };

        let result = generate_username(request, &client).await;
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), "context456@mozmail.com");

        server.verify().await;
    }
}

#[cfg(test)]
mod fastmail_tests {
    use super::*;

    #[tokio::test]
    async fn test_fastmail_successful_generation() {
        let server = MockServer::start().await;
        let client = create_test_client();

        // Mock JMAP session endpoint
        server
            .register(
                Mock::given(method("GET"))
                    .and(path("/.well-known/jmap"))
                    .respond_with(ResponseTemplate::new(200).set_body_json(json!({
                        "primaryAccounts": {
                            "https://www.fastmail.com/dev/maskedemail": "account123"
                        }
                    }))),
            )
            .await;

        // Mock masked email creation
        server
            .register(
                Mock::given(method("POST"))
                    .and(path("/jmap/api/"))
                    .respond_with(ResponseTemplate::new(200).set_body_json(json!({
                        "methodResponses": [
                            ["MaskedEmail/set", {
                                "created": {
                                    "new-masked-email": {
                                        "email": "masked789@fastmail.com"
                                    }
                                }
                            }]
                        ]
                    }))),
            )
            .await;

        let service = ForwarderServiceType::Fastmail {
            api_token: "fastmail_token".to_string(),
        };

        let request = UsernameGeneratorRequest::Forwarded {
            service,
            website: Some("example.com".to_string()),
        };

        let result = generate_username(request, &client).await;
        assert!(result.is_ok());
        let email = result.unwrap();
        assert_eq!(email, "masked789@fastmail.com");
        assert!(is_valid_email(&email));

        server.verify().await;
    }

    #[tokio::test]
    async fn test_fastmail_unauthorized() {
        let server = MockServer::start().await;
        let client = create_test_client();

        server
            .register(
                Mock::given(method("GET"))
                    .and(path("/.well-known/jmap"))
                    .respond_with(ResponseTemplate::new(401)),
            )
            .await;

        let service = ForwarderServiceType::Fastmail {
            api_token: "invalid_token".to_string(),
        };

        let request = UsernameGeneratorRequest::Forwarded {
            service,
            website: None,
        };

        let result = generate_username(request, &client).await;
        assert!(result.is_err());
        assert!(matches!(result.unwrap_err(), UsernameError::InvalidApiKey));

        server.verify().await;
    }
}

#[cfg(test)]
mod forwardemail_tests {
    use super::*;

    #[tokio::test]
    async fn test_forwardemail_successful_generation() {
        let server = MockServer::start().await;
        let client = create_test_client();

        server
            .register(
                Mock::given(method("POST"))
                    .and(path("/v1/domains/testdomain.com/aliases"))
                    .and(header("authorization", "Basic Zm9yd2FyZF90b2tlbjo=")) // base64("forward_token:")
                    .respond_with(ResponseTemplate::new(201).set_body_json(json!({
                        "name": "alias456",
                        "domain": {
                            "name": "testdomain.com"
                        }
                    }))),
            )
            .await;

        let service = ForwarderServiceType::ForwardEmail {
            api_token: "forward_token".to_string(),
            domain: "testdomain.com".to_string(),
        };

        let request = UsernameGeneratorRequest::Forwarded {
            service,
            website: Some("github.com".to_string()),
        };

        let result = generate_username(request, &client).await;
        assert!(result.is_ok());
        let email = result.unwrap();
        assert_eq!(email, "alias456@testdomain.com");
        assert!(is_valid_email(&email));

        server.verify().await;
    }

    #[tokio::test]
    async fn test_forwardemail_with_labels() {
        let server = MockServer::start().await;
        let client = create_test_client();

        server
            .register(
                Mock::given(method("POST"))
                    .and(path("/v1/domains/mydomain.org/aliases"))
                    .and(wiremock::matchers::body_json(json!({
                        "labels": "example.com",
                        "description": "Generated by Bitwarden for example.com"
                    })))
                    .respond_with(ResponseTemplate::new(201).set_body_json(json!({
                        "name": "labeled789",
                        "domain": {
                            "name": "mydomain.org"
                        }
                    }))),
            )
            .await;

        let service = ForwarderServiceType::ForwardEmail {
            api_token: "forward_token".to_string(),
            domain: "mydomain.org".to_string(),
        };

        let request = UsernameGeneratorRequest::Forwarded {
            service,
            website: Some("example.com".to_string()),
        };

        let result = generate_username(request, &client).await;
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), "labeled789@mydomain.org");

        server.verify().await;
    }
}

#[cfg(test)]
mod simplelogin_tests {
    use super::*;

    #[tokio::test]
    async fn test_simplelogin_successful_generation() {
        let server = MockServer::start().await;
        let client = create_test_client();

        server
            .register(
                Mock::given(method("POST"))
                    .and(path("/api/alias/random/new"))
                    .and(header("authentication", "simple_token"))
                    .respond_with(ResponseTemplate::new(201).set_body_json(json!({
                        "alias": "random123@simplelogin.co"
                    }))),
            )
            .await;

        let service = ForwarderServiceType::SimpleLogin {
            api_key: "simple_token".to_string(),
            base_url: server.uri(),
        };

        let request = UsernameGeneratorRequest::Forwarded {
            service,
            website: None,
        };

        let result = generate_username(request, &client).await;
        assert!(result.is_ok());
        let email = result.unwrap();
        assert_eq!(email, "random123@simplelogin.co");
        assert!(is_valid_email(&email));

        server.verify().await;
    }

    #[tokio::test]
    async fn test_simplelogin_with_hostname() {
        let server = MockServer::start().await;
        let client = create_test_client();

        server
            .register(
                Mock::given(method("POST"))
                    .and(path("/api/alias/random/new"))
                    .and(query_param("hostname", "github.com"))
                    .and(wiremock::matchers::body_json(json!({
                        "note": "Generated by SecureGen"
                    })))
                    .respond_with(ResponseTemplate::new(201).set_body_json(json!({
                        "alias": "github456@simplelogin.co"
                    }))),
            )
            .await;

        let service = ForwarderServiceType::SimpleLogin {
            api_key: "simple_token".to_string(),
            base_url: server.uri(),
        };

        let request = UsernameGeneratorRequest::Forwarded {
            service,
            website: Some("github.com".to_string()),
        };

        let result = generate_username(request, &client).await;
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), "github456@simplelogin.co");

        server.verify().await;
    }
}

#[cfg(test)]
mod integration_tests {
    use super::*;

    #[tokio::test]
    async fn test_all_forwarders_error_handling() {
        let server = MockServer::start().await;
        let client = create_test_client();

        // Setup server to return 500 for all requests
        server
            .register(
                Mock::given(method("POST"))
                    .respond_with(ResponseTemplate::new(500).set_body_raw("Internal Server Error", "text/plain")),
            )
            .await;

        server
            .register(
                Mock::given(method("GET"))
                    .respond_with(ResponseTemplate::new(500).set_body_raw("Internal Server Error", "text/plain")),
            )
            .await;

        let services = vec![
            ForwarderServiceType::AddyIo {
                api_token: "token".to_string(),
                domain: "domain.com".to_string(),
                base_url: server.uri(),
            },
            ForwarderServiceType::DuckDuckGo {
                token: "token".to_string(),
            },
            ForwarderServiceType::Firefox {
                api_token: "token".to_string(),
            },
            ForwarderServiceType::Fastmail {
                api_token: "token".to_string(),
            },
            ForwarderServiceType::ForwardEmail {
                api_token: "token".to_string(),
                domain: "domain.com".to_string(),
            },
            ForwarderServiceType::SimpleLogin {
                api_key: "token".to_string(),
                base_url: server.uri(),
            },
        ];

        for service in services {
            let request = UsernameGeneratorRequest::Forwarded {
                service,
                website: Some("test.com".to_string()),
            };

            let result = generate_username(request, &client).await;
            assert!(result.is_err(), "Service should return error for 500 response");
            
            // Should be an Http error due to 500 status
            if let Err(UsernameError::Http(_)) = result {
                // Expected
            } else {
                panic!("Expected Http error, got: {:?}", result);
            }
        }
    }

    #[tokio::test]
    async fn test_concurrent_requests() {
        let server = MockServer::start().await;
        let client = create_test_client();

        // Mock responses for multiple concurrent requests
        server
            .register(
                Mock::given(method("POST"))
                    .and(path("/api/v1/aliases"))
                    .respond_with(ResponseTemplate::new(201).set_body_json(json!({
                        "data": {
                            "email": "concurrent@domain.com"
                        }
                    })))
                    .expect(5), // Expect 5 calls
            )
            .await;

        // Create 5 concurrent requests
        let mut handles = Vec::new();
        for i in 0..5 {
            let client_clone = client.clone();
            let server_uri = server.uri();
            
            let handle = tokio::spawn(async move {
                let service = ForwarderServiceType::AddyIo {
                    api_token: format!("token_{}", i),
                    domain: "domain.com".to_string(),
                    base_url: server_uri,
                };

                let request = UsernameGeneratorRequest::Forwarded {
                    service,
                    website: Some(format!("site{}.com", i)),
                };

                generate_username(request, &client_clone).await
            });
            
            handles.push(handle);
        }

        // Wait for all requests to complete
        let results = futures::future::join_all(handles).await;
        
        // All should succeed
        for result in results {
            let username_result = result.expect("Task should not panic");
            assert!(username_result.is_ok(), "Request should succeed");
            assert_eq!(username_result.unwrap(), "concurrent@domain.com");
        }

        server.verify().await;
    }

    #[tokio::test]
    async fn test_network_timeout() {
        let client = reqwest::Client::builder()
            .timeout(Duration::from_millis(100)) // Very short timeout
            .build()
            .expect("Failed to create client");

        // Use a non-responsive address
        let service = ForwarderServiceType::AddyIo {
            api_token: "token".to_string(),
            domain: "domain.com".to_string(),
            base_url: "http://10.255.255.1:12345".to_string(), // Non-routable IP
        };

        let request = UsernameGeneratorRequest::Forwarded {
            service,
            website: None,
        };

        let result = generate_username(request, &client).await;
        assert!(result.is_err());
        
        // Should be a timeout error
        if let Err(UsernameError::Http(http_err)) = result {
            assert!(http_err.is_timeout() || http_err.is_connect());
        } else {
            panic!("Expected Http timeout error, got: {:?}", result);
        }
    }

    #[tokio::test]
    async fn test_malformed_response_handling() {
        let server = MockServer::start().await;
        let client = create_test_client();

        // Return invalid JSON
        server
            .register(
                Mock::given(method("POST"))
                    .respond_with(ResponseTemplate::new(200).set_body_raw("invalid json {{", "text/plain")),
            )
            .await;

        let service = ForwarderServiceType::AddyIo {
            api_token: "token".to_string(),
            domain: "domain.com".to_string(),
            base_url: server.uri(),
        };

        let request = UsernameGeneratorRequest::Forwarded {
            service,
            website: None,
        };

        let result = generate_username(request, &client).await;
        assert!(result.is_err());
        
        // Should be a deserialization error
        if let Err(UsernameError::Http(_)) = result {
            // Expected
        } else {
            panic!("Expected Http error for malformed JSON, got: {:?}", result);
        }

        server.verify().await;
    }
}

/// Stress test to verify system stability under load
#[cfg(test)]
mod stress_tests {
    use super::*;
    use std::sync::atomic::{AtomicUsize, Ordering};
    use std::sync::Arc;

    #[tokio::test]
    async fn test_high_load_generation() {
        let server = MockServer::start().await;
        let client = create_test_client();
        
        // Setup server to handle many requests
        server
            .register(
                Mock::given(method("POST"))
                    .respond_with(ResponseTemplate::new(201).set_body_json(json!({
                        "data": {
                            "email": "stress@test.com"
                        }
                    })))
                    .expect(100), // Expect 100 requests
            )
            .await;

        let success_count = Arc::new(AtomicUsize::new(0));
        let error_count = Arc::new(AtomicUsize::new(0));
        
        // Create 100 concurrent tasks
        let mut handles = Vec::new();
        for i in 0..100 {
            let client_clone = client.clone();
            let server_uri = server.uri();
            let success_count_clone = Arc::clone(&success_count);
            let error_count_clone = Arc::clone(&error_count);
            
            let handle = tokio::spawn(async move {
                let service = ForwarderServiceType::AddyIo {
                    api_token: format!("stress_token_{}", i),
                    domain: "test.com".to_string(),
                    base_url: server_uri,
                };

                let request = UsernameGeneratorRequest::Forwarded {
                    service,
                    website: Some("stress.com".to_string()),
                };

                match generate_username(request, &client_clone).await {
                    Ok(_) => {
                        success_count_clone.fetch_add(1, Ordering::SeqCst);
                    }
                    Err(_) => {
                        error_count_clone.fetch_add(1, Ordering::SeqCst);
                    }
                }
            });
            
            handles.push(handle);
        }

        // Wait for all tasks to complete
        futures::future::join_all(handles).await;
        
        let successes = success_count.load(Ordering::SeqCst);
        let errors = error_count.load(Ordering::SeqCst);
        
        // Should have high success rate
        assert!(successes >= 95, "Should have at least 95% success rate, got {} successes, {} errors", successes, errors);
        assert_eq!(successes + errors, 100, "Should process all 100 requests");

        server.verify().await;
    }
} 